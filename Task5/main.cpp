#include <iostream>
#include <cmath>
#include <ctime>

int main(){ //точка входа

unsigned int start_time =  clock(); // начальное время

setlocale(LC_ALL, "Russian");// локализация

double mass[20] =  { 0.0112, -2.014, -2.562, 5.892, 4.042, 0.132, -0.0004, -3.105, -2.306, 2.306, 3.173, -5.719, -0.456, 3.482, -2.486, 0.0002, -4.324, -6.140, -0.0008, 2.451 };

double newMass[20]; // новый массив

double productEvenIndexes{1}; // произведение чисел с четными индексами

double sumZeroBorders{0}; // сумма элементов между нулевыми границами

int firstZero{}, secondZero{}; // переменные, хранящие границы, а именно индексы нулевых элементов

int counter{}; // счетчик для запоминания последнего элемента в массиве

/* Задание 1, вычисление произведения элементов с четными номерами */
std::cout << "+--------+------------------------------------------------------+\n| Task 1 | вычисление произведения элементов с четными номерами |\n+--------+------------------------------------------------------+"<< std::endl;

for(int i{}; i < 20; i += 2){

    productEvenIndexes *= mass[i];

}

std::cout <<"Произведение чисел с четными индексами _> "<< productEvenIndexes << std::endl; // вывод результата

/* Задание 2, вычисление суммы между нулевыми элементами */
// поиск индекса первого нулевого элемента

std::cout << "+--------+--------------------------------------------+\n| Task 2 | вычисление суммы между нулевыми элементами |\n+--------+--------------------------------------------+" << std::endl;

// поиск первого нулевого элемента

for(int i{}; i < 20; i++){

    if(fabs(mass[i]) < 0.001){ // если найден первый нулевой элемент 

        firstZero = i; // запоминаем индекс

        break;  // ломаем цикл

    }
    
}

// поиск последнего нулевого элемента

for(int i{19}; i >= 0; i--){

    if(fabs(mass[i]) < 0.001){ // если найден последний нулевой элемент 

        secondZero = i; // запоминаем индекс

        break;  // ломаем цикл

    }
    
}

// Просуммируем не включая в сумму края

for(int i = firstZero + 1; i < secondZero; i++){ 

    sumZeroBorders += mass[i];

}

std::cout << "Промежуток: (" << firstZero << " : " << secondZero << ")\n" << "Результат суммирования _> " << sumZeroBorders << std::endl; // Отладочная строка

// Задание 3 преобразовать массив, поделить на четные / нечетные

std::cout << "+--------+--------------------+\n| Task 3 | сортировка массива |\n+--------+--------------------+" << std::endl;

for(int i{}; i < 20; i++){ // делаем перебор массива и вносим положительные числа

    if(fabs(mass[i]) < 0.001){

        newMass[counter] = 0; // записываем 0 в массив
        counter++; //инкрементируем индекс для записи следующего значения (запоминаем куда писать следующий элемент)
    
    }
    else if(mass[i] > 0){
        newMass[counter] = mass[i]; // записываем положительное число в массив
        counter++; //инкрементируем индекс для записи следующего значения (запоминаем куда писать следующий элемент)

    }

}

for(int i{}; i < 20; i++){ // делаем перебор массива и вносим отрицательные числа

    if(fabs(mass[i]) > 0.001 && mass[i] < 0){

        newMass[counter] = mass[i];
        counter++; //инкрементируем индекс для записи следующего значения (запоминаем куда писать следующий элемент)
    
    }

}
std::cout << "Отсортированный массив:\n";

for(int i{}; i < 20; i += 4){ // вывод в 5 строчек по 4 элемента

    std::cout << "| " << newMass[i] << " | " << newMass[i+1] << " | " << newMass[i+2] << " | " << newMass[i+3] << " |\n";

}

unsigned int end_time = clock(); // конечное время
std::cout << "\nВремя выполнения программы: "<< end_time - start_time << " [мсек]\n";

}